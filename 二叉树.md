时间复杂度： 函数调用的次数 * 每次函数调用的时间消耗

空间复杂度： stack（栈空间） heap（堆空间）

二叉树深度优先遍历： 时间复杂度：o（n）【遍历都为o（n)】

66；前序；67:中序；68:后序：69:层级遍历 70: 层级遍历II  71:锯齿形遍历


广度遍历又叫层次遍历。用队列实现，依次将根，左子树，右子树存入队列，按照队列的先进先出规则来实现层次遍历。

# 层次遍历（广度优先）
```
def BFS(root):
    if root:
        res = []
        queue = [root]
        while queue:
            currentNode = queue.pop(0)
            res.append(currentNode.val)
            if currentNode.left:
                queue.append(currentNode.left)
            if currentNode.right:
                queue.append(currentNode.right)
    return res

```
深度优先遍历
用栈实现，先将根入栈，再将根出栈，并将根的右子树，左子树存入栈，按照栈的先进后出规则来实现深度优先遍历。

# 深度优先
```
def DFS(root):
    if root:
        res = []
        stack = [root]
        while stack:
            currentNode = stack.pop()
            res.append(currentNode.val)
            if currentNode.right:
                stack.append(currentNode.right)
            if currentNode.left:
                stack.append(currentNode.left)
    return res
```
前序遍历的深度优先  [1,2,3] lintcode:69
```
class Solution:
    """
    @param root: A Tree
    @return: Level order a list of lists of integer
    """
    #dfs
    def levelOrder(self, root):
        # write your code here
        result = []
        if root is None:
            return result
            
        self.traversal(root, result)
        return result

    def traversal(self, root, result):
        if root is None:
            return

        result.append(root.val)
        self.traversal(root.left, result)
        self.traversal(root.right, result)

        return
```
需要分层次 [[1],[2,3]] 

lintcode:
481 · Binary Tree Leaf Sum
482 · Binary Tree Level Sum
```
class Solution:
    """
    @param root: A Tree
    @return: Level order a list of lists of integer
    """
    def levelOrder(self, root):
        # write your code here
        result = []
        if root is None:
            return result
        thislevel = 0
        self.traversal(root, result, thislevel)
        return result

    def traversal(self, root, result, thislevel):
        if root is None:
            return
        if thislevel >= len(result):
            result.append([])
        result[thislevel].append(root.val)
        thislevel += 1
        self.traversal(root.left, result, thislevel)
        self.traversal(root.right, result, thislevel)

        return
```
深层遍历 + 回溯：可以遍历出root-leaf的每条path {1,2,4,2,3,5,6} ->[[1,2,2],[1,2,3],[1,4,5],[1,4,6]]
lintcode: 376 · Binary Tree Path Sum
```
   def binaryTreePathSum(self, root, targetSum):
        if not root:
            return []
        res = []
        self.dfs(root, res, [], targetSum)
        return res
        
    def dfs(self, root, res, path, target):
        path.append(root.val)
     
        if not root.left and not root.right:
            res.append(path[:])

        if root.left:
            self.dfs(root.left, res, path, target - root.val)
            path.pop()
        if root.right:
            self.dfs(root.right, res, path, target - root.val)
            path.pop()
```
