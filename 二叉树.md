时间复杂度： 函数调用的次数 * 每次函数调用的时间消耗

空间复杂度： stack（栈空间） heap（堆空间）

二叉树深度优先遍历： 时间复杂度：o（n）【遍历都为o（n)】

66；前序；67:中序；68:后序：69:层级遍历 70: 层级遍历II  71:锯齿形遍历


广度遍历又叫层次遍历。用队列实现，依次将根，左子树，右子树存入队列，按照队列的先进先出规则来实现层次遍历。

# 层次遍历（广度优先）
```
def BFS(root):
    if root:
        res = []
        queue = [root]
        while queue:
            currentNode = queue.pop(0)
            res.append(currentNode.val)
            if currentNode.left:
                queue.append(currentNode.left)
            if currentNode.right:
                queue.append(currentNode.right)
    return res

```
深度优先遍历
用栈实现，先将根入栈，再将根出栈，并将根的右子树，左子树存入栈，按照栈的先进后出规则来实现深度优先遍历。

# 深度优先
```
def DFS(root):
    if root:
        res = []
        stack = [root]
        while stack:
            currentNode = stack.pop()
            res.append(currentNode.val)
            if currentNode.right:
                stack.append(currentNode.right)
            if currentNode.left:
                stack.append(currentNode.left)
    return res
```
前序遍历的深度优先  [1,2,3] lintcode:69
```
class Solution:
    """
    @param root: A Tree
    @return: Level order a list of lists of integer
    """
    #dfs
    def levelOrder(self, root):
        # write your code here
        result = []
        if root is None:
            return result
            
        self.traversal(root, result)
        return result

    def traversal(self, root, result):
        if root is None:
            return

        result.append(root.val)
        self.traversal(root.left, result)
        self.traversal(root.right, result)

        return
```
需要分层次 [[1],[2,3]] 

lintcode:

481 · Binary Tree Leaf Sum
482 · Binary Tree Level Sum(https://github.com/mazexiaozhoulu/Leetcode-/blob/719e0ec707e8e99c01f16c5378de5c9a4468081d/lintcode%20482%20%C2%B7%20Binary%20Tree%20Level%20Sum.md)
97 · Maximum Depth of Binary Tree(https://github.com/mazexiaozhoulu/Leetcode-/blob/719e0ec707e8e99c01f16c5378de5c9a4468081d/lintcode%2097,%20leetcode%20104%20104.%20Maximum%20Depth%20of%20Binary%20Tree.md)
```
class Solution:
    """
    @param root: A Tree
    @return: Level order a list of lists of integer
    """
    def levelOrder(self, root):
        # write your code here
        result = []
        if root is None:
            return result
        thislevel = 0
        self.traversal(root, result, thislevel)
        return result

    def traversal(self, root, result, thislevel):
        if root is None:
            return
        if thislevel >= len(result):
            result.append([])
        result[thislevel].append(root.val)
        thislevel += 1
        self.traversal(root.left, result, thislevel)
        self.traversal(root.right, result, thislevel)

        return
```
深层遍历 + 回溯：可以遍历出root-leaf的每条path {1,2,4,2,3,5,6} ->[[1,2,2],[1,2,3],[1,4,5],[1,4,6]]

lintcode: 
376 · Binary Tree Path Sum 
480 · Binary Tree Paths
leetcode:

[111. Minimum Depth of Binary Tree](https://github.com/mazexiaozhoulu/Leetcode-/blob/940c77fef827251af6fccaede50cc3349090910e/leetcode%20111.%20Minimum%20Depth%20of%20Binary%20Tree.md)
```
class Solution:
    """
    @param root: The root of binary tree
    @return: An integer
    """
    def minDepth(self, root):
        # write your code here
        res = []
        if not root:
            return 0
        paths = []
        self.dfs(root, [root], paths)
        return paths

    def dfs(self, root, path, paths):
        if not root:
            return 0

        if not root.left and not root.right:
            paths.append([str(n.val)for n in path])

        path.append(root.left)
        self.dfs(root.left, path, paths)
        path.pop()
        path.append(root.right)
        self.dfs(root.right, path, paths)
        path.pop()
```
